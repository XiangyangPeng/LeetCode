记录在LeetCode上刷题过程中的思考和总结，包括题型，思维方式，注意要点

刷题方式：起初是打算从头到尾挨个做下来，后来发现一个一个专题进行训练可能更有效。每一个专题按照顺序是同一个套路由易到难的变化。

- 题型

  - 双指针
    - 删除排序数组重复项
    - 链表删除重复数字，重排等等（类似于chaser and runner来着）

  - 二分法
    - 数据溢出：因为存在+1，两个int相加的运算
    - right=mid(-1),left=mid(+1)，括号里的内容加不加会影响最终的输出结果，要根据具体情况判断。正确的使用可以简化程序
      - 这里存在一个问题，while的条件必然是(left<right)，而不能是(left<=right)（会陷入死循环），跳出循环的条件则是(left==right)或(left>right)
        - 如果right=mid,left=mid，可能陷入死循环，必须至少有一个会-1或+1
        - 如果right=mid,left=mid+1，总是以left==right跳出循环，并且在保证初始时的right对应的值不满足搜索条件时，可以直接返回“未搜索到结果”
        - 如果right=mid-1,left=mid，以left==right或left>right跳出循环，若以left==right跳出循环，在保证初始时的left不满足搜索条件时，或者，以left>right跳出循环，可以直接返回"未搜索到结果"
        - 如果right=mid-1,left=mid+1，以left==right或left>right跳出循环，若以left==right跳出循环，需要再判断此时对应的值是否满足搜索条件，若不满足，可以返回"未搜索到结果"
    - mid=(left+right)/2与mid=(right+left+1)/2的区别

  - 数组
    - 题型
      - 组合之和	
      - 数组排列的转换（二维数组）
      - 删除重复元素
      - 用数组表示多位数
      - 等等
    - 常用方法
      - 递归
      - 二分
      - 常常需要从数学的角度来思考算法

  - 动态规划
    - 朴素递归算法之所以效率较低，是因为它反复求解相同的子问题
    - 步骤
      - 刻画一个最优解的结构特征——将问题表达成更小一级问题的递归式
      - 递归地定义最优解的值——寻找到一个准确的递归表达式并准确的赋予初始值
      - 计算最优解的值，通常采用自底向上的方法
      - 利用计算出的信息构造一个最优解
    - 不要用递归，要用循环。

  - 深度优先搜索（二叉树相关）

    - 基本知识

      - 二叉搜索树（二叉排序树，二叉查找树）
      - 平衡二叉树

    - 基本方法

      - 递归

      - 非递归：栈的使用

        - 二叉树的中序遍历的非递归方法

          - ```
            void InOrderTraversal(BinTree BT)
            { 
                BinTree T = BT;
                Stack S = CreatStack(MaxSize); //创建并初始化堆栈S
                while(T || !IsEmpty(S))
            　　{
                　　while(T)    //一直向左并将沿途节点压入堆栈
                　　{ 
                   　　 Push(S,T);
                    　　T = T->Left;
                　　}
                　　if(!IsEmpty(S))
                　　{
                   　　 T = Pop(S);                //节点弹出堆栈
                   　　 printf("%d\n", T->Data);    //（访问） 打印结点
                  　　  T = T->Right;              //转向右子树
                　　}
            　　}
            }
            ```

            

- 编程技巧

  - 减小时间复杂度

    - 高级的算法思想
      - 分治：常常能将$O(n^2)$降低为$O(nlogn)$ ——递归
      - 动态规划：充分利用已经计算的信息，减少重复工作——迭代
    - 剪枝
    - trick：双指针，快慢指针找中点 ，chaser and runner   ......

  - 测试

    - 脏数据

    - 极端用例：空输入，非法输入

    - 数据溢出

      - 可能溢出的情况
        - 输入数据为整型数据，而处理过程中存在加法和乘法
        - 有符号整数，负数转化为正整数——int:$[-2^{31},2^{31}-1]$
      - 解决方法
        - 用无符号类型代替有符号类型——uint:$[0,2^{32}-1]$，并不能表示很大的数
        - 用long类型代替int——涉及到大数运算的时候，如(int)*10
        - 添加溢出判断
        - 灵活调整运算顺序，使得每一步运算都不会溢出(D=A-C+B替代D=A+B-C)

  - debug

    - 首先检查代码有没有那个地方写串了。有时候复制粘贴的时候该改的地方没有改
    - 代码逻辑
      - 基础知识不扎实，有些写法不能正确表达自己的意思
      - 变量的管理不严密，导致它的值出现意料之外的变化
    - 考虑的情况不完备

    

- 编程习惯

  - 不要想当然，对自己写下的每一个字符都要负责
  
  - 循环
  -  ++$i$ 比 $i$++执行效率高
    - 对于循环赋值的变量，注意每一次循环之后是否要对变量重新初始化

    - 循环变量不要忘记自增或自减

  - 数组，向量
  
  - 随时注意判断是否越界
  
- 判断
    - 1==a 比 a==1 更能避免错误

    - 嵌套的if语句相比于并行的if语句更加安全，不要随便将两者转换。但也要按照实际情况认真思考

    - bool变量取反是!而不是~
  
    - if的嵌套
  
      - ```
        if(tp[i]+tp[j]<K){
        	if(tp[i]+tp[j]>max)max=tp[i]+tp[j];
      }//必须加大括号才能保证程序逻辑
        else
          break;
        ```

  - 索引

    - 对数组、向量进行索引之前注意index的值是否一定合法：nums[-1]...

  - 字符串

    - <string>.length()返回一个无符号整数，做运算的时候要考虑溢出

  - 返回值return

    - 在不同的return 语句前添加输出前处理语句，不要遗漏

  - 容器

    - 迭代器iterator对每一个容器是特定的，不能相互混用
  
  - 结构体
  
    - 定义结构体指针与定义类指针一样使用new：`Person *p=new Person();`