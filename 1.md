记录在LeetCode上刷题过程中的思考和总结，包括题型，思维方式，注意要点

刷题方式：起初是打算从头到尾挨个做下来，后来发现一个一个专题进行训练可能更有效。

- 题型

  - 双指针
    - 删除排序数组重复项
    - 链表删除重复数字，重排等等（类似于chaser and runner来着）
  - 二分法
    - 数据溢出：因为存在+1，两个int相加的运算
    - right=mid(-1),left=mid(+1)，括号里的内容加不加会影响最终的输出结果，要根据具体情况判断。正确的使用可以简化程序
      - 这里存在一个问题，while的条件必然是(left<right)，而不能是(left<=right)（会陷入死循环），跳出循环的条件则是(left==right)或(left>right)
        - 如果right=mid,left=mid，可能陷入死循环，必须至少有一个会-1或+1
        - 如果right=mid,left=mid+1，总是以left==right跳出循环，并且在保证初始时的right对应的值不满足搜索条件时，可以直接返回“未搜索到结果”
        - 如果right=mid-1,left=mid，以left==right或left>right跳出循环，若以left==right跳出循环，在保证初始时的left不满足搜索条件时，或者，以left>right跳出循环，可以直接返回"未搜索到结果"
        - 如果right=mid-1,left=mid+1，以left==right或left>right跳出循环，若以left==right跳出循环，需要再判断此时对应的值是否满足搜索条件，若不满足，可以返回"未搜索到结果"
    - mid=(left+right)/2与mid=(right+left+1)/2的区别
  - 数组
    - 题型
      - 组合之和	
      - 数组排列的转换（二维数组）
      - 删除重复元素
      - 用数组表示多位数
      - 等等
    - 常用方法
      - 递归
      - 二分
      - 常常需要从数学的角度来思考算法
  - 动态规划
    - 朴素递归算法之所以效率较低，是因为它反复求解相同的子问题
    - 步骤
      - 刻画一个最优解的结构特征——将问题表达成更小一级问题的递归式
      - 递归地定义最优解的值——寻找到一个准确的递归表达式并准确的赋予初始值
      - 计算最优解的值，通常采用自底向上的方法
      - 利用计算出的信息构造一个最优解
    - 不要用递归，要用循环。

- 编程技巧

  - 减小时间复杂度

    - 高级的算法思想
      - 分治：常常能将$O(n^2)$降低为$O(nlogn)$ ——递归
      - 动态规划：充分利用已经计算的信息，减少重复工作——迭代
    - 剪枝
    - trick：双指针，chaser and runner   ......

  - 测试

    - 脏数据

    - 极端用例：空输入，非法输入

    - 数据溢出：看到输入数据为整型数据，而处理过程中存在加法和乘法的时候，一定要注意可能的溢出！！！

      - 利用无符号类型代替有符号类型
      - 添加溢出判断

      

- 编程习惯

  - 循环
    -  ++$i$ 比 $i$++执行效率高
    - 对于循环赋值的变量，注意每一次循环之后是否要对变量重新初始化
  - 数组，向量
    - 随时注意判断是否越界
  - 判断
    -  1==a 比 a==1 更能避免错误
  - 索引
    - 对数组、向量进行索引之前注意index的值是否一定合法：nums[-1]...